import abc
from typing import Optional

import numpy as np
from _typeshed import Incomplete

torch_is_available: bool
OPTIONAL: str
CURRENT_BINARY_VERSION: int
ACCEPTED_MODEL_TYPES: Incomplete

def visit_spec(spec, fn, scope: str = ...) -> None: ...
def index_spec(spec, index): ...

class FrozenMeta(type):
    def __call__(self, *args, **kwargs): ...

class FrozenAttr:
    def __setattr__(self, key, value) -> None: ...

class LayerSpec(FrozenAttr, metaclass=FrozenMeta):
    def validate(self) -> None: ...
    def variables(
        self, prefix: str = ..., ordered: bool = ...
    ) -> dict[str, np.ndarray]: ...
    def optimize(self, quantization: Optional[str] = ...) -> None: ...

class ModelConfig(FrozenAttr, metaclass=FrozenMeta):
    def __init__(self, **kwargs) -> None: ...
    def to_dict(self): ...
    def save_as_json(self, path) -> None: ...

class ModelSpec(LayerSpec):
    def __init__(self) -> None: ...
    @property
    def name(self) -> None: ...
    @property
    def revision(self): ...
    @property
    def config(self): ...
    def get_default_config(self) -> None: ...
    def register_file(self, path: str, filename: Optional[str] = ...) -> None: ...
    def save(self, output_dir: str) -> None: ...

class SequenceToSequenceModelConfig(ModelConfig):
    def __init__(
        self,
        unk_token: str = ...,
        bos_token: str = ...,
        eos_token: str = ...,
        decoder_start_token: Optional[str] = ...,
        add_source_bos: bool = ...,
        add_source_eos: bool = ...,
        **kwargs,
    ) -> None: ...

class SequenceToSequenceModelSpec(ModelSpec, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def get_default_config(self): ...
    @abc.abstractmethod
    def get_source_vocabulary_size(self): ...
    @abc.abstractmethod
    def get_target_vocabulary_size(self): ...
    def register_source_vocabulary(self, tokens: list[str]) -> None: ...
    def register_target_vocabulary(self, tokens: list[str]) -> None: ...
    def register_vocabulary_mapping(self, path: str) -> None: ...
    def validate(self) -> None: ...
    def save(self, output_dir: str) -> None: ...

class LanguageModelConfig(ModelConfig):
    def __init__(
        self, unk_token: str = ..., bos_token: str = ..., eos_token: str = ..., **kwargs
    ) -> None: ...

class LanguageModelSpec(ModelSpec, metaclass=abc.ABCMeta):
    def __init__(self) -> None: ...
    def get_default_config(self): ...
    @abc.abstractmethod
    def get_vocabulary_size(self): ...
    def register_vocabulary(self, tokens: list[str]) -> None: ...
    def validate(self) -> None: ...
    def save(self, output_dir: str) -> None: ...

class Variable(abc.ABC, metaclass=abc.ABCMeta):
    @property
    @abc.abstractmethod
    def shape(self) -> list[int]: ...
    def is_scalar(self) -> bool: ...
    @property
    @abc.abstractmethod
    def dtype(self) -> str: ...
    def to(self, dtype: str) -> Variable: ...
    @abc.abstractmethod
    def numpy(self) -> np.ndarray: ...
    def equal(self, other) -> bool: ...
    @abc.abstractmethod
    def num_bytes(self) -> int: ...
    @abc.abstractmethod
    def to_bytes(self) -> bytes: ...

class NumpyVariable(Variable):
    array: Incomplete
    def __init__(self, array) -> None: ...
    @property
    def shape(self) -> list[int]: ...
    @property
    def dtype(self) -> str: ...
    def numpy(self) -> np.ndarray: ...
    def num_bytes(self) -> int: ...
    def to_bytes(self) -> bytes: ...

class PyTorchVariable(Variable):
    tensor: Incomplete
    def __init__(self, tensor) -> None: ...
    @classmethod
    def from_numpy(cls, array): ...
    @property
    def shape(self) -> list[int]: ...
    @property
    def dtype(self) -> str: ...
    def numpy(self) -> np.ndarray: ...
    def num_bytes(self) -> int: ...
    def to_bytes(self) -> bytes: ...
