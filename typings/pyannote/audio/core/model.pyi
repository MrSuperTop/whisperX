from functools import cached_property as cached_property
from pathlib import Path
from typing import Any, Dict, List, Optional, Text, Tuple, Union

import pytorch_lightning as pl
import torch.nn as nn
import torch.optim
from _typeshed import Incomplete, StrPath
from pyannote.audio.core.task import Specifications
from pyannote.audio.core.task import Task as Task
from pyannote.core import SlidingWindow
from torch.utils.data import DataLoader as DataLoader

CACHE_DIR: Incomplete
HF_PYTORCH_WEIGHTS_NAME: str
HF_LIGHTNING_CONFIG_NAME: str

class Introspection: ...

class Output:
    num_frames: int
    dimension: int
    frames: SlidingWindow
    def __init__(self, num_frames, dimension, frames) -> None: ...

class Model(pl.LightningModule):
    audio: Incomplete
    def __init__(self, sample_rate: int = ..., num_channels: int = ..., task: Optional[Task] = ...) -> None: ...
    @property
    def task(self) -> Task: ...
    def build(self) -> None: ...
    @property
    def specifications(self) -> Union[Specifications, Tuple[Specifications]]: ...
    @property
    def example_input_array(self) -> torch.Tensor: ...
    @cached_property
    def example_output(self) -> Union[Output, Tuple[Output]]: ...
    task_dependent: Incomplete
    def setup(self, stage: Incomplete | None = ...) -> None: ...
    def on_save_checkpoint(self, checkpoint) -> None: ...
    def on_load_checkpoint(self, checkpoint: Dict[str, Any]): ...
    def forward(self, waveforms: torch.Tensor, **kwargs) -> Union[torch.Tensor, Tuple[torch.Tensor]]: ...
    def default_activation(self) -> Union[nn.Module, Tuple[nn.Module]]: ...
    def train_dataloader(self) -> DataLoader: ...
    def training_step(self, batch, batch_idx): ...
    def val_dataloader(self) -> DataLoader: ...
    def validation_step(self, batch, batch_idx): ...
    def configure_optimizers(self): ...
    def freeze_up_to(self, module_name: Text) -> List[Text]: ...
    def unfreeze_up_to(self, module_name: Text) -> List[Text]: ...
    def freeze_by_name(self, modules: Union[Text, List[Text]], recurse: bool = ...) -> List[Text]: ...
    def unfreeze_by_name(self, modules: Union[List[Text], Text], recurse: bool = ...) -> List[Text]: ...
    @classmethod
    def from_pretrained(cls, checkpoint: Union[Path, Text], map_location: StrPath | None = ..., hparams_file: StrPath = ..., strict: bool = ..., use_auth_token: Union[Text, None] = ..., cache_dir: Union[Path, Text] = ..., **kwargs: Any) -> Model: ...
