from typing import Optional

import numpy as np
from _typeshed import Incomplete
from pyannote.core import (
    Annotation as Annotation,
)
from pyannote.core import (
    SlidingWindowFeature as SlidingWindowFeature,
)
from pyannote.core import (
    Timeline,
)
from pyannote.metrics.base import BaseMetric

def discrete_diarization_error_rate(reference: np.ndarray, hypothesis: np.ndarray): ...

class DiscreteDiarizationErrorRate(BaseMetric):
    @classmethod
    def metric_name(cls): ...
    @classmethod
    def metric_components(cls): ...
    def compute_components(
        self, reference, hypothesis, uem: Optional[Timeline] = ...
    ): ...
    def compute_components_helper(
        self, hypothesis, reference, uem: Optional[Timeline] = ...
    ): ...
    def der_from_ndarray(
        self,
        hypothesis: np.ndarray,
        reference: np.ndarray,
        uem: Optional[Timeline] = ...,
    ): ...
    def der_from_swf(
        self,
        hypothesis: SlidingWindowFeature,
        reference: Annotation,
        uem: Optional[Timeline] = ...,
    ): ...
    def compute_metric(self, components): ...

class SlidingDiarizationErrorRate(BaseMetric):
    window: Incomplete
    def __init__(self, window: float = ...) -> None: ...
    @classmethod
    def metric_name(cls): ...
    @classmethod
    def metric_components(cls): ...
    def compute_components(
        self, reference, hypothesis, uem: Optional[Timeline] = ...
    ): ...
    def compute_metric(self, components): ...

class MacroAverageFMeasure(BaseMetric):
    def metric_components(self): ...
    @classmethod
    def metric_name(cls): ...
    metric_name_: Incomplete
    classes: Incomplete
    components_: Incomplete
    collar: Incomplete
    beta: Incomplete
    def __init__(
        self, classes: list[str], collar: float = ..., beta: float = ..., **kwargs
    ) -> None: ...
    def reset(self) -> None: ...
    def compute_components(
        self,
        reference: Annotation,
        hypothesis: Annotation,
        uem: Incomplete | None = ...,
        **kwargs,
    ): ...
    def compute_metric(self, detail: dict[str, float]): ...
    def report(self, display: bool = ...): ...
    def __abs__(self): ...
