import numpy as np
from _typeshed import Incomplete
from pyannote.core import Annotation as Annotation, SlidingWindowFeature as SlidingWindowFeature, Timeline
from pyannote.metrics.base import BaseMetric
from typing import Dict, List, Optional

def discrete_diarization_error_rate(reference: np.ndarray, hypothesis: np.ndarray): ...

class DiscreteDiarizationErrorRate(BaseMetric):
    @classmethod
    def metric_name(cls): ...
    @classmethod
    def metric_components(cls): ...
    def compute_components(self, reference, hypothesis, uem: Optional[Timeline] = ...): ...
    def compute_components_helper(self, hypothesis, reference, uem: Optional[Timeline] = ...): ...
    def der_from_ndarray(self, hypothesis: np.ndarray, reference: np.ndarray, uem: Optional[Timeline] = ...): ...
    def der_from_swf(self, hypothesis: SlidingWindowFeature, reference: Annotation, uem: Optional[Timeline] = ...): ...
    def compute_metric(self, components): ...

class SlidingDiarizationErrorRate(BaseMetric):
    window: Incomplete
    def __init__(self, window: float = ...) -> None: ...
    @classmethod
    def metric_name(cls): ...
    @classmethod
    def metric_components(cls): ...
    def compute_components(self, reference, hypothesis, uem: Optional[Timeline] = ...): ...
    def compute_metric(self, components): ...

class MacroAverageFMeasure(BaseMetric):
    def metric_components(self): ...
    @classmethod
    def metric_name(cls): ...
    metric_name_: Incomplete
    classes: Incomplete
    components_: Incomplete
    collar: Incomplete
    beta: Incomplete
    def __init__(self, classes: List[str], collar: float = ..., beta: float = ..., **kwargs) -> None: ...
    def reset(self) -> None: ...
    def compute_components(self, reference: Annotation, hypothesis: Annotation, uem: Incomplete | None = ..., **kwargs): ...
    def compute_metric(self, detail: Dict[str, float]): ...
    def report(self, display: bool = ...): ...
    def __abs__(self): ...
