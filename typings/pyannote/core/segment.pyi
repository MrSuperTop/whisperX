from typing import Iterable, Iterator, Optional, Union

import numpy as np
from _typeshed import Incomplete

from .utils.types import Alignment as Alignment

class Segment:
    start: float
    end: float
    @staticmethod
    def set_precision(ndigits: Optional[int] = ...): ...
    def __bool__(self) -> bool: ...
    def __post_init__(self) -> None: ...
    @property
    def duration(self) -> float: ...
    @property
    def middle(self) -> float: ...
    def __iter__(self) -> Iterator[float]: ...
    def copy(self) -> Segment: ...
    def __contains__(self, other: Segment): ...
    def __and__(self, other): ...
    def intersects(self, other: Segment) -> bool: ...
    def overlaps(self, t: float) -> bool: ...
    def __or__(self, other: Segment) -> Segment: ...
    def __xor__(self, other: Segment) -> Segment: ...
    def __init__(self, start, end) -> None: ...
    def __lt__(self, other): ...
    def __gt__(self, other): ...
    def __le__(self, other): ...
    def __ge__(self, other): ...

class SlidingWindow:
    def __init__(
        self,
        duration: float = ...,
        step: float = ...,
        start: float = ...,
        end: Incomplete | None = ...,
    ) -> None: ...
    @property
    def start(self) -> float: ...
    @property
    def end(self) -> float: ...
    @property
    def step(self) -> float: ...
    @property
    def duration(self) -> float: ...
    def closest_frame(self, t: float) -> int: ...
    def samples(self, from_duration: float, mode: Alignment = ...) -> int: ...
    def crop(
        self,
        focus: Union[Segment, Timeline],
        mode: Alignment = ...,
        fixed: Optional[float] = ...,
        return_ranges: Optional[bool] = ...,
    ) -> Union[np.ndarray, list[list[int]]]: ...
    def segmentToRange(self, segment: Segment) -> tuple[int, int]: ...
    def segment_to_range(self, segment: Segment) -> tuple[int, int]: ...
    def rangeToSegment(self, i0: int, n: int) -> Segment: ...
    def range_to_segment(self, i0: int, n: int) -> Segment: ...
    def samplesToDuration(self, nSamples: int) -> float: ...
    def samples_to_duration(self, n_samples: int) -> float: ...
    def durationToSamples(self, duration: float) -> int: ...
    def duration_to_samples(self, duration: float) -> int: ...
    def __getitem__(self, i: int) -> Segment: ...
    def next(self) -> Segment: ...
    def __next__(self) -> Segment: ...
    def __iter__(self) -> SlidingWindow: ...
    def __len__(self) -> int: ...
    def copy(self) -> SlidingWindow: ...
    def __call__(
        self, support: Union[Segment, Timeline], align_last: bool = ...
    ) -> Iterable[Segment]: ...
