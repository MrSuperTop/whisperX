from typing import (
    Callable,
    Dict,
    Iterable,
    Iterator,
    List,
    Optional,
    Sequence,
    Text,
    TextIO,
    Tuple,
    Union,
)

import pandas as pd
from _typeshed import Incomplete
from sortedcontainers import SortedList

from . import PYANNOTE_SEGMENT as PYANNOTE_SEGMENT
from .annotation import Annotation as Annotation
from .segment import Segment as Segment
from .utils.types import CropMode as CropMode
from .utils.types import Label as Label
from .utils.types import Support as Support

class Timeline:
    @classmethod
    def from_df(cls, df: pd.DataFrame, uri: Optional[str] = ...) -> Timeline: ...
    segments_set_: Incomplete
    segments_list_: Sequence[Segment]
    segments_boundaries_: Incomplete
    uri: Incomplete
    def __init__(self, segments: Optional[Iterable[Segment]] = ..., uri: str = ...) -> None: ...
    def __len__(self) -> int: ...
    def __nonzero__(self): ...
    def __bool__(self) -> bool: ...
    def __iter__(self) -> Iterable[Segment]: ...
    def __getitem__(self, k: int) -> Segment: ...
    def __eq__(self, other: Timeline): ...
    def __ne__(self, other: Timeline): ...
    def index(self, segment: Segment) -> int: ...
    def add(self, segment: Segment) -> Timeline: ...
    def remove(self, segment: Segment) -> Timeline: ...
    def discard(self, segment: Segment) -> Timeline: ...
    def __ior__(self, timeline: Timeline) -> Timeline: ...
    def update(self, timeline: Segment) -> Timeline: ...
    def __or__(self, timeline: Timeline) -> Timeline: ...
    def union(self, timeline: Timeline) -> Timeline: ...
    def co_iter(self, other: Timeline) -> Iterator[Tuple[Segment, Segment]]: ...
    def crop_iter(self, support: Support, mode: CropMode = ..., returns_mapping: bool = ...) -> Iterator[Union[Tuple[Segment, Segment], Segment]]: ...
    def crop(self, support: Support, mode: CropMode = ..., returns_mapping: bool = ...) -> Union['Timeline', Tuple['Timeline', Dict[Segment, Segment]]]: ...
    def overlapping(self, t: float) -> List[Segment]: ...
    def overlapping_iter(self, t: float) -> Iterator[Segment]: ...
    def get_overlap(self) -> Timeline: ...
    def extrude(self, removed: Support, mode: CropMode = ...) -> Timeline: ...
    def __contains__(self, included: Union[Segment, 'Timeline']): ...
    def empty(self) -> Timeline: ...
    def covers(self, other: Timeline) -> bool: ...
    def copy(self, segment_func: Optional[Callable[[Segment], Segment]] = ...) -> Timeline: ...
    def extent(self) -> Segment: ...
    def support_iter(self, collar: float = ...) -> Iterator[Segment]: ...
    def support(self, collar: float = ...) -> Timeline: ...
    def duration(self) -> float: ...
    def gaps_iter(self, support: Optional[Support] = ...) -> Iterator[Segment]: ...
    def gaps(self, support: Optional[Support] = ...) -> Timeline: ...
    def segmentation(self) -> Timeline: ...
    def to_annotation(self, generator: Union[str, Iterable[Label], None, None] = ..., modality: Optional[str] = ...) -> Annotation: ...
    def to_uem(self) -> Text: ...
    def write_uem(self, file: TextIO): ...
