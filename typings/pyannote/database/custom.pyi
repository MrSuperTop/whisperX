from .loader import load_lst as load_lst, load_trial as load_trial
from .protocol.protocol import Scope as Scope, Subset as Subset
from .protocol.segmentation import SegmentationProtocol as SegmentationProtocol
from .protocol.speaker_diarization import SpeakerDiarizationProtocol as SpeakerDiarizationProtocol
from .util import get_annotated as get_annotated
from _typeshed import Incomplete
from pathlib import Path
from pyannote.database.protocol.protocol import ProtocolFile
from typing import Any, Callable, Dict, Text, Union

LOADERS: Incomplete

def Template(template: Text, database_yml: Path) -> Callable[[ProtocolFile], Any]: ...
def NumericValue(value): ...
def resolve_path(path: Path, database_yml: Path) -> Path: ...
def meta_subset_iter(meta_database: Text, meta_task: Text, meta_protocol: Text, meta_subset: Subset, subset_entries: Dict, database_yml: Path): ...
def gather_loaders(entries: Dict, database_yml: Path) -> dict: ...
def subset_iter(self, database: Text = ..., task: Text = ..., protocol: Text = ..., subset: Subset = ..., entries: Dict = ..., database_yml: Path = ..., **metadata): ...
def subset_trial(self, database: Text = ..., task: Text = ..., protocol: Text = ..., subset: Subset = ..., entries: Dict = ..., database_yml: Path = ...): ...
def get_init(protocols): ...
def get_custom_protocol_class_name(database: Text, task: Text, protocol: Text): ...
def create_protocol(database: Text, task: Text, protocol: Text, protocol_entries: Dict, database_yml: Path) -> Union[type, None]: ...
