from typing import Optional, Union

import pandas as pd
from _typeshed import Incomplete
from pyannote.core import Annotation as Annotation
from pyannote.core import Timeline as Timeline
from pyannote.metrics.types import (
    Details as Details,
)
from pyannote.metrics.types import (
    MetricComponents as MetricComponents,
)

class BaseMetric:
    @classmethod
    def metric_name(cls) -> str: ...
    @classmethod
    def metric_components(cls) -> MetricComponents: ...
    metric_name_: Incomplete
    components_: Incomplete
    def __init__(self, **kwargs) -> None: ...
    def init_components(self): ...
    accumulated_: Incomplete
    results_: Incomplete
    def reset(self) -> None: ...
    @property
    def name(self): ...
    def __call__(
        self,
        reference: Union[Timeline, Annotation],
        hypothesis: Union[Timeline, Annotation],
        detailed: bool = ...,
        uri: Optional[str] = ...,
        **kwargs,
    ): ...
    def report(self, display: bool = ...) -> pd.DataFrame: ...
    def __abs__(self): ...
    def __getitem__(self, component: str) -> Union[float, Details]: ...
    def __iter__(self): ...
    def compute_components(
        self,
        reference: Union[Timeline, Annotation],
        hypothesis: Union[Timeline, Annotation],
        **kwargs,
    ) -> Details: ...
    def compute_metric(self, components: Details): ...
    def confidence_interval(
        self, alpha: float = ...
    ) -> tuple[float, tuple[float, float]]: ...

PRECISION_NAME: str
PRECISION_RETRIEVED: str
PRECISION_RELEVANT_RETRIEVED: str

class Precision(BaseMetric):
    @classmethod
    def metric_name(cls): ...
    @classmethod
    def metric_components(cls) -> MetricComponents: ...
    def compute_metric(self, components: Details) -> float: ...

RECALL_NAME: str
RECALL_RELEVANT: str
RECALL_RELEVANT_RETRIEVED: str

class Recall(BaseMetric):
    @classmethod
    def metric_name(cls): ...
    @classmethod
    def metric_components(cls) -> MetricComponents: ...
    def compute_metric(self, components: Details) -> float: ...

def f_measure(precision: float, recall: float, beta: float = ...) -> float: ...
